<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【算法笔记】ACM技能树</title>
    <url>/posts/al_acm/</url>
    <content><![CDATA[<h1>基本算法</h1>
<h2 id="枚举">枚举</h2>
<p>枚举也称作穷举，指的是从问题所有可能的解的集合中一一枚举各元素。枚举算法简单粗暴，他暴力的枚举所有可能，尽可能地尝试所有的方法。</p>
<p>练习题单：<a href="https://www.luogu.com.cn/training/108#problems">暴力枚举</a></p>
<h2 id="模拟">模拟</h2>
<p>模拟，是根据实际问题建立模型，模拟实际按程序走一遍，最终求出答案。</p>
<p>练习题单：<a href="https://www.luogu.com.cn/training/106#problems">模拟与高精度</a></p>
<h2 id="贪心">贪心</h2>
<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。</p>
<p><strong>关键词：局部最优解</strong></p>
<p>练习题单：<a href="https://www.luogu.com.cn/training/110#problems">贪心</a></p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P1223">P1223 排队接水</a></p>
<p>思路：第一个人无需等待，第二个人需要等待第一个人接完水，平均时间取决于第一个人的接水时间，第三个人同理，只要前两个人的接水时间最短，平均等待时间就最小。局部最优解可推广到全局最优解。</p>
<p>所以对时间从小到大排序即可，接水时间越短，排队越靠前。</p>
<p>参考代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">times = <span class="built_in">input</span>().split()</span><br><span class="line"></span><br><span class="line"><span class="comment"># times_map 人员编号与接水时间的映射关系</span></span><br><span class="line">times_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(times):</span><br><span class="line">    times_map[<span class="built_in">str</span>(i+<span class="number">1</span>)] = <span class="built_in">int</span>(times[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按时间从小到大排序</span></span><br><span class="line">times_map = <span class="built_in">sorted</span>(times_map.items(), key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取编号列表</span></span><br><span class="line">index = []</span><br><span class="line"><span class="comment"># 求总的等待时间</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(times_map):</span><br><span class="line">    index.append(v[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + v[<span class="number">1</span>]*(n-i-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(index))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">sum</span> / n))</span><br></pre></td></tr></table></figure>
<h2 id="分治">分治</h2>
<p>分治算法的基本思想是将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</p>
<p><strong>分治，即分而治之，将大问题分解为小问题，分别求解，最后合并结果。</strong></p>
<p>练习题单：<a href="https://www.luogu.com.cn/training/202#problems">分治</a></p>
<h2 id="递归">递归</h2>
<p>递归，就是在运行的过程中调用自己。</p>
<p>练习题单：<a href="https://www.luogu.com.cn/training/109#problems">递推与递归</a></p>
<h1>搜索</h1>
<h2 id="深度优先搜索">深度优先搜索</h2>
<p>深度优先搜索属于图算法的一种，英文缩写为 DFS 即 Depth First Search，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p>
<p>练习题：<a href="https://www.luogu.com.cn/problem/P1219">八皇后 Checker Challenge</a></p>
<h2 id="广度优先搜索">广度优先搜索</h2>
<p>广度优先搜索是最简便的图搜索算法之一，别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p>
<p>练习题：<a href="https://www.luogu.com.cn/problem/P1443">P1443 马的遍历</a></p>
<h2 id="双向搜索">双向搜索</h2>
<p>问题：在起点和终点已知的情况下，需要确定能否从起点到达终点，如果可以，需要多少步。</p>
<p>除了可以使用从起点开始的单向搜索以外，还可以从起点和终点出发，判断能否相遇，提高搜索效率。</p>
<p>练习题1：<a href="https://www.luogu.com.cn/problem/P1379">P1379 八数码难题</a></p>
<p>练习题2：<a href="https://www.luogu.com.cn/problem/P2324">P2324 [SCOI2005]骑士精神</a></p>
<p>练习题1思路：题目给出了搜索的起点和终点，可使用双向BFS。</p>
<p>练习题1参考代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution(in.nextInt());     <span class="comment">// 输入起始的棋盘布局</span></span><br><span class="line">        solution.doubleBFS();       <span class="comment">// 执行双向搜索</span></span><br><span class="line">        System.out.println(solution.step);  <span class="comment">// 输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startValue; <span class="comment">// 起始布局，用数字表示</span></span><br><span class="line">    <span class="keyword">int</span> endValue;   <span class="comment">// 目标布局(已知)</span></span><br><span class="line">    <span class="keyword">int</span> step;   <span class="comment">// 所需要的步数</span></span><br><span class="line">    <span class="keyword">int</span>[][] forword = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;  <span class="comment">// 移动方向</span></span><br><span class="line">    <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>];     <span class="comment">// 棋盘布局</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; searchState = <span class="keyword">new</span> HashMap&lt;&gt;();    <span class="comment">// 记录双向搜索的状态</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; solutionStep = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">// 记录对应搜索所需的步数</span></span><br><span class="line"></span><br><span class="line">    Solution(<span class="keyword">int</span> startValue)&#123;</span><br><span class="line">        <span class="keyword">this</span>.startValue = startValue;   <span class="comment">// 初始化起始布局和目标布局</span></span><br><span class="line">        <span class="keyword">this</span>.endValue = <span class="number">123804765</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将棋盘转化为数字，容易判断和记录</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数字转换为棋盘布局，方便移动</span></span><br><span class="line">    <span class="keyword">int</span>[] toMatrix(<span class="keyword">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] zero = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">100000000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">                matrix[i][j] = (num/div)%<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    zero[<span class="number">0</span>] = i;</span><br><span class="line">                    zero[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">                div/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否超出棋盘布局</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cheack</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;<span class="number">3</span> &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换棋盘上的两个值（0与周围某一点的值）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> nx, <span class="keyword">int</span> ny)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = matrix[nx][ny];</span><br><span class="line">        matrix[nx][ny] = matrix[x][y];</span><br><span class="line">        matrix[x][y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doubleBFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startValue == endValue) <span class="keyword">return</span>;  <span class="comment">// 起始布局等于目标布局，直接退出</span></span><br><span class="line">        LinkedList&lt;Integer&gt; head = <span class="keyword">new</span> LinkedList&lt;&gt;(), tail = <span class="keyword">new</span> LinkedList&lt;&gt;();   <span class="comment">// head表示从起点开始搜索，tail表示从终点开始搜索</span></span><br><span class="line">        head.add(startValue);   <span class="comment">// 添加起始布局</span></span><br><span class="line">        tail.add(endValue);     <span class="comment">// 添加目标布局</span></span><br><span class="line">        searchState.put(startValue, <span class="number">1</span>);  <span class="comment">// 给head搜索设置状态1</span></span><br><span class="line">        searchState.put(endValue, <span class="number">2</span>);      <span class="comment">// 给tail搜索设置状态2，状态不同，可用来判断两搜索是否相遇，相遇即可结束搜索</span></span><br><span class="line">        solutionStep.put(startValue, <span class="number">0</span>);    <span class="comment">// 设置起始搜索的起始步数为0</span></span><br><span class="line">        solutionStep.put(endValue, <span class="number">1</span>);      <span class="comment">// 设置终点搜索的起始步数为1，这样当两搜索相遇时，总步数为 两步数之和</span></span><br><span class="line">        <span class="keyword">while</span> (!head.isEmpty() &amp;&amp; !tail.isEmpty())&#123;     <span class="comment">// 和单向BFS搜索一样，用队列存储</span></span><br><span class="line">            <span class="keyword">int</span> isHead = <span class="number">1</span>; <span class="comment">// 判断本次使用哪一种搜索</span></span><br><span class="line">            <span class="keyword">int</span> currentValue = <span class="number">0</span>;   <span class="comment">// 记录当前从栈中取出的值</span></span><br><span class="line">            <span class="keyword">if</span>(head.size()&gt;tail.size())&#123;    <span class="comment">// 优先拓展搜索树小的队列</span></span><br><span class="line">                currentValue = tail.pollFirst();</span><br><span class="line">                isHead = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                currentValue = head.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[] zero = toMatrix(currentValue);    <span class="comment">// 将数字转化为棋盘布局，返回0的坐标</span></span><br><span class="line">            <span class="keyword">int</span> x = zero[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = zero[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;    <span class="comment">// 拓展可移动布局的点</span></span><br><span class="line">                <span class="keyword">int</span> newX = x+forword[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y+forword[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(cheack(newX, newY))&#123;</span><br><span class="line">                    swap(x, y, newX, newY);     <span class="comment">// 更新布局</span></span><br><span class="line">                    <span class="keyword">int</span> newValue = toInt();     <span class="comment">// 获取新的数字</span></span><br><span class="line">                    <span class="keyword">int</span> currentState = searchState.getOrDefault(currentValue, <span class="number">0</span>);   <span class="comment">// 记录更新前的状态</span></span><br><span class="line">                    <span class="keyword">int</span> newState = searchState.getOrDefault(newValue, <span class="number">0</span>);       <span class="comment">// 记录新状态</span></span><br><span class="line">                    <span class="keyword">if</span>(solutionStep.getOrDefault(newValue, <span class="number">0</span>) == <span class="number">0</span>)&#123;        <span class="comment">// 如果当前布局没有探索过</span></span><br><span class="line">                        searchState.put(newValue, isHead);      <span class="comment">// 设置状态，即标记当前是哪一种搜索</span></span><br><span class="line">                        solutionStep.put(newValue, solutionStep.get(currentValue)+<span class="number">1</span>);   <span class="comment">// 设置新布局的步数</span></span><br><span class="line">                        <span class="keyword">if</span>(isHead == <span class="number">1</span>)&#123;</span><br><span class="line">                            head.add(newValue);  <span class="comment">// 将新值添加到对应的搜索树中</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            tail.add(newValue);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((newState + currentState) == <span class="number">3</span>)&#123;  <span class="comment">// 如果起点搜索和终点搜索相遇，可结束搜索</span></span><br><span class="line">                        step = solutionStep.get(currentValue)+solutionStep.get(newValue);  <span class="comment">// 更新步数</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    swap(x, y, newX, newY);  <span class="comment">// 从新布局恢复，为下一次更换布局做准备</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="记忆化搜索">记忆化搜索</h2>
<p>记忆化搜索是在搜索的过程中，将已经计算出来的结果保存起来，当之后的计算用到的时候直接取出结果，避免重复运算，提高了算法的效率。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P1464">P1464 Function</a></p>
<p>思路：按照题目的描述写就行，递归+记忆化</p>
<p>参考代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> a, b, c;</span><br><span class="line">        a = in.nextLong();</span><br><span class="line">        b = in.nextLong();</span><br><span class="line">        c = in.nextLong();</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        # 大于<span class="number">20</span>的值最终还是返回w(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">while</span>(!(a==-<span class="number">1</span> &amp;&amp; b==-<span class="number">1</span> &amp;&amp; c==-<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> x=(<span class="keyword">int</span>)a, y=(<span class="keyword">int</span>)b ,z=(<span class="keyword">int</span>)c;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;<span class="number">21</span>) x=<span class="number">21</span>;</span><br><span class="line">            <span class="keyword">if</span>(b&gt;<span class="number">21</span>) y=<span class="number">21</span>;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;<span class="number">21</span>) z=<span class="number">21</span>;</span><br><span class="line">            s.w(x, y, z);</span><br><span class="line">            out.printf(<span class="string">&quot;w(%d, %d, %d) = %d\n&quot;</span>, a, b, c, s.w(x, y, z));</span><br><span class="line">            a = in.nextLong();</span><br><span class="line">            b = in.nextLong();</span><br><span class="line">            c = in.nextLong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    # 存储已经计算出结果的值</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> [][][] used = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line">    # 递归，如果该值已经算出，就不用继续算了，直接从存储单元取出</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=<span class="number">0</span> || b&lt;=<span class="number">0</span> || c&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(used[a][b][c]!=<span class="number">0</span>) <span class="keyword">return</span> used[a][b][c];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&gt;<span class="number">20</span> || b&gt;<span class="number">20</span> || c&gt;<span class="number">20</span>)&#123;</span><br><span class="line">            used[a][b][c] = w(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;b &amp;&amp; b&lt;c)&#123;</span><br><span class="line">            used[a][b][c] = w(a, b, c-<span class="number">1</span>)+w(a, b-<span class="number">1</span>, c-<span class="number">1</span>)-w(a, b-<span class="number">1</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            used[a][b][c] = w(a-<span class="number">1</span>, b, c)+w(a-<span class="number">1</span>, b-<span class="number">1</span>, c)+w(a-<span class="number">1</span>, b, c-<span class="number">1</span>)-w(a-<span class="number">1</span>, b-<span class="number">1</span>, c-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> used[a][b][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启发式搜索">启发式搜索</h2>
<p>启发式搜索就是在状态空间的搜索中对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无谓的搜索路径，提高了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果。</p>
<p>启发中的估价是用估价函数表示的，如：f(n) = g(n) + h(n)</p>
<h1>动态规划</h1>
<h2 id="背包问题">背包问题</h2>
<h3 id="01背包">01背包</h3>
<h3 id="多重背包">多重背包</h3>
<h3 id="完全背包">完全背包</h3>
<h2 id="数位DP">数位DP</h2>
<h2 id="状压DP">状压DP</h2>
<h2 id="区间DP">区间DP</h2>
<h2 id="树形DP">树形DP</h2>
<h2 id="优化方法">优化方法</h2>
<h3 id="滚动数组">滚动数组</h3>
<h3 id="二分优化">二分优化</h3>
<h3 id="矩阵优化">矩阵优化</h3>
<h3 id="斜率优化">斜率优化</h3>
<h3 id="四边形不等式优化">四边形不等式优化</h3>
<h3 id="数据结构优化">数据结构优化</h3>
<h1>数据结构</h1>
<h2 id="基础数据结构">基础数据结构</h2>
<h3 id="向量">向量</h3>
<h3 id="栈">栈</h3>
<h3 id="队列">队列</h3>
<h3 id="链表">链表</h3>
<h3 id="堆">堆</h3>
<h3 id="树">树</h3>
<h3 id="集合">集合</h3>
<h3 id="映射">映射</h3>
<h2 id="高级数据结构">高级数据结构</h2>
<h3 id="单调栈">单调栈</h3>
<h3 id="单调队列">单调队列</h3>
<h3 id="ST表">ST表</h3>
<h3 id="并查集">并查集</h3>
<h4 id="带权并查集">带权并查集</h4>
<h4 id="种类并查集">种类并查集</h4>
<h3 id="树状数组">树状数组</h3>
<h3 id="线段树">线段树</h3>
<h4 id="ZKW线段树">ZKW线段树</h4>
<h4 id="权值线段树">权值线段树</h4>
<h4 id="主席树">主席树</h4>
<h3 id="平衡树">平衡树</h3>
<h4 id="Splay伸展树">Splay伸展树</h4>
<h4 id="Treap树堆">Treap树堆</h4>
<h4 id="替罪羊树">替罪羊树</h4>
<h4 id="珂朵莉树">珂朵莉树</h4>
<h4 id="KD树">KD树</h4>
<h3 id="字典树">字典树</h3>
<h3 id="舞蹈链-dancing-links">舞蹈链(dancing links)</h3>
<h3 id="树链剖分">树链剖分</h3>
<h3 id="LCT-动态森林">LCT(动态森林)</h3>
<h1>图论</h1>
<h2 id="最短路">最短路</h2>
<ul>
<li>Dijkstra算法</li>
<li>Bellam-Ford算法</li>
<li>Floyd算法</li>
<li>SPFA算法</li>
<li>差分约束</li>
</ul>
<h2 id="最小生成树">最小生成树</h2>
<ul>
<li>Prime算法</li>
<li>Kruskal算法</li>
</ul>
<h2 id="二分图">二分图</h2>
<ul>
<li>二分图判断</li>
<li>匈牙利算法</li>
<li>KM算法</li>
</ul>
<h2 id="网络流">网络流</h2>
<ul>
<li>最大流(Dicnic)</li>
<li>最小费用流(spfa费用流)</li>
<li>有界网络流</li>
</ul>
<h2 id="拓扑排序">拓扑排序</h2>
<ul>
<li>2-SAT</li>
<li>欧拉图与哈密尔顿图</li>
</ul>
<h1>数论</h1>
<h2 id="模运算">模运算</h2>
<ul>
<li>同余</li>
<li>快速幂</li>
</ul>
<h2 id="欧几里得定理">欧几里得定理</h2>
<h2 id="拓展欧几里得">拓展欧几里得</h2>
<h2 id="线性同余方程">线性同余方程</h2>
<h2 id="中国剩余定理">中国剩余定理</h2>
<h2 id="乘法逆元">乘法逆元</h2>
<h2 id="二次同余方程">二次同余方程</h2>
<h2 id="唯一分解定理">唯一分解定理</h2>
<h2 id="素数">素数</h2>
<ul>
<li>素数筛</li>
<li>素性测试</li>
<li>反素数</li>
</ul>
<h2 id="欧拉函数">欧拉函数</h2>
<h2 id="欧拉降幂公式">欧拉降幂公式</h2>
<h2 id="积性函数">积性函数</h2>
<h2 id="莫比乌斯函数">莫比乌斯函数</h2>
<h2 id="原根">原根</h2>
<h2 id="离散对数">离散对数</h2>
<h2 id="偏序关系">偏序关系</h2>
<h1>组合数学</h1>
<h2 id="排列">排列</h2>
<ul>
<li>不可重排列</li>
<li>可重排列</li>
<li>圆排列</li>
<li>不尽相异元素全排列</li>
<li>多重集的排列</li>
</ul>
<h2 id="组合">组合</h2>
<ul>
<li>不可重组合</li>
<li>可重组合</li>
<li>不相邻组合</li>
<li>多重集的组合</li>
<li>大组合数取模</li>
</ul>
<h2 id="常用公式与定理">常用公式与定理</h2>
<ul>
<li>二项式定理</li>
<li>常见恒等式</li>
<li>鸽巢原理</li>
<li>容斥原理</li>
<li>帕斯卡恒等式</li>
<li>卢卡斯定理</li>
<li>错排问题</li>
</ul>
<h2 id="常见数列">常见数列</h2>
<ul>
<li>斐波那契数列</li>
<li>卡特兰数列</li>
</ul>
<h2 id="递推方程">递推方程</h2>
<ul>
<li>线性递推方程</li>
<li>非线性递推方程</li>
<li>BM算法</li>
</ul>
<h2 id="母函数">母函数</h2>
<ul>
<li>普通母函数</li>
<li>指数型母函数</li>
</ul>
<h2 id="Polya计数">Polya计数</h2>
<h2 id="快速傅里叶-FFT">快速傅里叶(FFT)</h2>
<h1>字符串</h1>
<h2 id="manacher算法">manacher算法</h2>
<h2 id="字符串Hash">字符串Hash</h2>
<h2 id="KMP算法">KMP算法</h2>
<ul>
<li>普通KMP算法</li>
<li>拓展KMP算法</li>
</ul>
<h2 id="Trie字典树">Trie字典树</h2>
<ul>
<li>字典树</li>
<li>01字典树</li>
</ul>
<h2 id="自动机">自动机</h2>
<ul>
<li>AC自动机</li>
<li>回文自动机</li>
<li>后缀自动机</li>
</ul>
<h2 id="后缀数组">后缀数组</h2>
<h1>其他</h1>
<h2 id="分块算法">分块算法</h2>
<h2 id="莫队算法">莫队算法</h2>
<h2 id="CDQ分治">CDQ分治</h2>
<h2 id="尺取法">尺取法</h2>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法笔记】差分数组</title>
    <url>/posts/al_difference_array/</url>
    <content><![CDATA[<p>引入问题：</p>
<p>已知一个数组 a[10] ，初始值全部为1。 如果要将范围 [1, 5]之间的每一个数字都加1，应当如何操作。</p>
<p>最简单直接的操作就是for循环了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) a[i]++;</span><br></pre></td></tr></table></figure>
<p>但是如果数据范围较大，以及操作次数比较多，用for循环时间复杂度较高。</p>
<p>先看看什么是差分数组:</p>
<p><strong>简单来说，前一个元素减去后一个元素形成的数组就是差分数组。</strong></p>
<p><strong>d[0] = a[0]  （ i = 0 ）</strong></p>
<p><strong>d[i ] = a[i] - a[i - 1]  （ i  &gt; 0）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">举个例子：</span><br><span class="line"></span><br><span class="line">数组  a：</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span></span><br><span class="line"></span><br><span class="line">差分数组 d 应当是：</span><br><span class="line"><span class="number">1</span>，<span class="number">1</span>，<span class="number">1</span>，<span class="number">1</span>，<span class="number">1</span>     <span class="comment">//第一个元素没有可以减的元素，所以就等于它本身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即规定d[0] = a[0]</span></span><br></pre></td></tr></table></figure>
<p>我们注意到:</p>
<p>d[1] = a[1] - a[0]</p>
<p>d[2] = a[2] - a[1]</p>
<p>d[3] = a[3] - a[2]</p>
<p>d[4] = a[4] - a[3]</p>
<p>即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] = d[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = d[<span class="number">1</span>] + d[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>] = d[<span class="number">2</span>] + d[<span class="number">1</span>] + a[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">**......**</span><br><span class="line"></span><br><span class="line">可推导出 a[i] = d[i] + d[i<span class="number">-1</span>] + d[i<span class="number">-2</span>] + ...+d[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>所以差分数组到底有什么用呢？</p>
<p><strong>回到引入问题</strong>：</p>
<p>要使[ 1, 5 ] 之间的每个元素都+1，用差分数组只需要这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d[<span class="number">1</span>]++;</span><br><span class="line">d[<span class="number">5</span>+<span class="number">1</span>]--;</span><br></pre></td></tr></table></figure>
<p>因为d[1] = a[1] - a[0]，a[1]增大了，a[0]不变，所以d[1]应当加上相应的变化量。<br>
同理，中间的元素是同步增大的，所以无需处理。<br>
对于d [6] = a[6] - a[5]，a[5]增大了，a[6]不变，所以d[6]应当减去相应的变化量。</p>
<p>原本复杂的for循环，现在只需两行代码。</p>
<p>差分数组不仅仅是一个优秀的数据结构，还是一种很好的思想。<br>
修改区间的时间复杂度是O（1），查询点的时间复杂度为O（n）</p>
<p><strong>对应练习题：</strong></p>
<p>基础题： <a href="https://www.luogu.com.cn/problem/CF44C">CF44C Holidays</a>（差分数组）</p>
<p>进阶题：<a href="https://www.luogu.com.cn/problem/P4939">P4939 Agent2</a>（树状数组+差分数组）。</p>
<p>基础题代码 (Python版)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n, m = <span class="built_in">input</span>().split()</span><br><span class="line">n, m=<span class="built_in">int</span>(n), <span class="built_in">int</span>(m)</span><br><span class="line">out=<span class="literal">False</span></span><br><span class="line">d=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n+<span class="number">2</span>)]   <span class="comment">#d为差分数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,m):</span><br><span class="line">    a, b=<span class="built_in">input</span>().split()</span><br><span class="line">    a, b=<span class="built_in">int</span>(a), <span class="built_in">int</span>(b)</span><br><span class="line">    d[a]+=<span class="number">1</span>                <span class="comment">#差分数组的更新</span></span><br><span class="line">    d[b+<span class="number">1</span>]-=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    count=<span class="built_in">sum</span>(d[<span class="number">0</span>:i+<span class="number">1</span>])   <span class="comment">#求第i天浇水的次数</span></span><br><span class="line">    <span class="keyword">if</span> count!=<span class="number">1</span>:         <span class="comment">#浇水次数不等于1就输出，结束</span></span><br><span class="line">        <span class="built_in">print</span>(i,count)</span><br><span class="line">        out=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> out:        <span class="comment">#没有问题就输出OK</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>进阶题代码(C++版)：<br>
(这题要用树状数组来维护更新)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">10000002</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &gt;= <span class="number">1</span>; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">		sum += d[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">		d[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = b+<span class="number">1</span> ; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">		d[i]--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> a, b, c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (c) &#123;</span><br><span class="line">			cin &gt;&gt; a;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">getSum</span>(a) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			<span class="built_in">update</span>(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法笔记】快速幂</title>
    <url>/posts/al_fast_power/</url>
    <content><![CDATA[<h1>基本思想</h1>
<p>引入问题：如何快速求出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">3^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> ？</p>
<p>暴力法：简单直接，for循环累乘，时间复杂度<code>O(n)</code></p>
<p>二分思想：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>10</mn></msup><mo>=</mo><msup><mn>3</mn><mn>5</mn></msup><mo>∗</mo><msup><mn>3</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">3^{10} = 3^{5} * 3^{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>5</mn></msup><mo>=</mo><mn>3</mn><mo>∗</mo><msup><mn>3</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">3^5=3*3^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>4</mn></msup><mo>=</mo><msup><mn>3</mn><mn>2</mn></msup><mo>∗</mo><msup><mn>3</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">3^4=3^2 *3^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>2</mn></msup><mo>=</mo><mn>3</mn><mo>∗</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3^2=3*3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></p>
<p>总共只需要计算4次。</p>
<p>基于这样一个过程，我们能够在O(log n)的时间复杂度内计算出幂，该算法也就是快速幂的基本思想。</p>
<h1>代码实现</h1>
<h2 id="递归版本-C语言实现">递归版本 - C语言实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">binaryPow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a*binaryPow(a, b<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll temp = binaryPow(a, b/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp*temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, binaryPow(a,b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="迭代版本-C语言实现">迭代版本 - C语言实现</h2>
<p>还是以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">3^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>为例 ，将10写成二进制形式，则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mrow><mo stretchy="false">(</mo><mn>1010</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow></msup></mrow><annotation encoding="application/x-tex">3^{(1010)_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mrow><mo stretchy="false">(</mo><mn>1010</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow></msup><mo>=</mo><msup><mn>3</mn><mrow><mo stretchy="false">(</mo><mn>1000</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow></msup><mo>∗</mo><msup><mn>3</mn><mrow><mo stretchy="false">(</mo><mn>10</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow></msup></mrow><annotation encoding="application/x-tex">3^{(1010)_2} = 3^{(1000)_2} * 3^{(10)_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> ，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mrow><mn>8</mn><mo>+</mo><mn>4</mn></mrow></msup><mo>=</mo><msup><mn>3</mn><mn>8</mn></msup><mo>∗</mo><msup><mn>3</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">3^{8+4} = 3^8*3^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="mbin mtight">+</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></p>
<p>而这些二进制形式的数，恰好就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">3^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">3^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">3^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">3^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>。后一个数是前一个数的平方。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">binaryPow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果b的二进制最后一位为1，也可以写成 b % 2 == 1;</span></span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            ans *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// a的平方</span></span><br><span class="line">        a = a*a;</span><br><span class="line">        <span class="comment">// b右移1位，也可以写成 b /= 2;</span></span><br><span class="line">        b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, binaryPow(a,b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>练习题</h1>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1226">P1226 【模板】快速幂||取余运算</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>KMP - 字符串匹配算法</title>
    <url>/posts/al_kmp/</url>
    <content><![CDATA[<h1>KMP思想</h1>
<p>对于暴力算法，如果出现不匹配字符，需要同时回退 <strong>文本串</strong> 和 <strong>模式串</strong> 的指针。KMP的主要思想是<strong>永不回退文本串的指针，而是利用前缀表将模式串移动到正确位置继续匹配。</strong></p>
<h1>什么是前缀表</h1>
<p>前缀表（prefix table），KMP算法中也经常被写为next数组。</p>
<h2 id="前缀表的作用">前缀表的作用</h2>
<p>利用前缀表，可以得知<strong>当前位置匹配失败时，新的模式串指针应该回退到哪里</strong>。文本串指针不变，从新的模式串指针继续匹配。（<strong>此时新模式串指针前的所有字符与文本串指针前的字符是匹配的，无需回退文本串指针</strong>）</p>
<h2 id="前缀表的计算">前缀表的计算</h2>
<p>前缀表要求的是<strong>最长相同前后缀</strong>，<code>前缀是指以第一个字符开头的连续子串（不包含最后一个字符），后缀是指以最后一个字符结尾的连续子串（不包含第一个字符）。</code></p>
<h1>代码实现</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建前缀表</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prefix_table</span><span class="params">(string pattern, <span class="keyword">int</span> *prefix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 如abcabc, i=5时，此时len = 2，&#x27;c&#x27;==&#x27;c&#x27;，匹配成功，len+1</span></span><br><span class="line">		<span class="keyword">if</span> (pattern[i] == pattern[len]) &#123;</span><br><span class="line">			len++;</span><br><span class="line">			prefix[i] = len;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// abdabc, i=5时，此时len=2, &#x27;d&#x27;!=&#x27;c&#x27;</span></span><br><span class="line">			<span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				len = prefix[len - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				prefix[i] = len;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀表右移，左补-1（方便使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move_prefix</span><span class="params">(<span class="keyword">int</span> *prefix , <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		prefix[i] = prefix[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	prefix[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_search</span><span class="params">(string text, string pattern)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = pattern.<span class="built_in">length</span>(), m = text.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">int</span> *prefix = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * n);</span><br><span class="line">	<span class="built_in">prefix_table</span>(pattern, prefix, n);</span><br><span class="line">	<span class="built_in">move_prefix</span>(prefix, n);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">        <span class="comment">// 成功找到了一个匹配串，继续找下一个可能的匹配串</span></span><br><span class="line">		<span class="keyword">if</span> (j == n - <span class="number">1</span> &amp;&amp; text[i] == pattern[j]) &#123;</span><br><span class="line">			cout &lt;&lt; i - j + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">			j = prefix[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (text[i] == pattern[j]) &#123;</span><br><span class="line">			i++; j++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 当前字符不匹配时，利用前缀表更新模式串的查找位置</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			j = prefix[j];</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">-1</span>) &#123;</span><br><span class="line">				j++; i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string text, pattern;</span><br><span class="line">	cin &gt;&gt; text &gt;&gt; pattern;</span><br><span class="line">	<span class="built_in">kmp_search</span>(text, pattern);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>时间复杂度</h1>
<p>生成前缀表的时间复杂度是O(m)，匹配的过程是O(n)，所以整个KMP算法的时间复杂度是<strong>O(n+m)</strong>。</p>
<h1>参考教程</h1>

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=11866460&bvid=BV1Px411z7Yo&cid=19594712&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div>


<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=16828557&bvid=BV1hW411a7ys&cid=27494484&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】学习笔记</title>
    <url>/posts/cs_network/</url>
    <content><![CDATA[<h1>一、应用层</h1>
<h2 id="Socket">Socket</h2>
<p>同一台主机内应用层与运输层之间的接口。</p>
<h2 id="TCP-UDP协议">TCP/UDP协议</h2>
<p>运输层协议</p>
<h3 id="TCP">TCP</h3>
<p>特点：面向连接、可靠数据传输服务。</p>
<ul>
<li>面向连接：三次握手，建立TCP连接。该连接是全双工的，双方可同时进行报文收发，结束报文发送之后必须关闭该连接。</li>
<li>可靠数据传输：无差错，按适当顺序交付所有发送的数据。</li>
</ul>
<p>TCP还具有拥塞控制机制。</p>
<h3 id="UDP">UDP</h3>
<p>无连接，不可靠数据传输服务，不保证报文能够到达目的主机，且报文顺序不保证有序。</p>
<h2 id="应用层协议">应用层协议</h2>
<p>公共协议(HTTP, SMTP)等，遵守协议规范开发的程序具有通用性。专用协议（不为公共域使用）。</p>
<h3 id="HTTP">HTTP</h3>
<p>HTTP是无状态协议，每次请求不记录客户端状态，相当于每一次都作为新访客对待。使用的运输层协议是<code>TCP</code>。</p>
<h4 id="HTTP协议报文格式">HTTP协议报文格式</h4>
<ul>
<li>
<p>HTTP请求报文</p>
<p>每行由一个回车和换行符结束 <code>\r\n</code></p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">方法 URL 版本\r\n</span><br><span class="line">首部字段名：值\r\n</span><br><span class="line">...</span><br><span class="line">首部字段名：值\r\n</span><br><span class="line">\r\n</span><br><span class="line">entity body    // GET或POST方法时，提交的值</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.github.com</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Mozilla/5.0</span><br><span class="line">Accept-language: en</span><br></pre></td></tr></table></figure>
<ul>
<li>HTTP 响应报文</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">版本 状态码 短语\r\n         // HTTP/1.1 200 OK</span><br><span class="line">首部字段名: 值\r\n  				// Server: Apache/2.2.3 (Centos)</span><br><span class="line">...</span><br><span class="line">首部字段名: 值\r\n</span><br><span class="line">\r\n</span><br><span class="line">entity body         // data data data...</span><br></pre></td></tr></table></figure>
<h4 id="常见状态码">常见状态码</h4>
<ul>
<li>200 OK</li>
<li>301 Moved Permanently</li>
<li>400 Bad Request</li>
<li>404 Not Found</li>
<li>505 HTTP Version Not Supported</li>
</ul>
<h1>编程作业-Python实现</h1>
<h2 id="使用TCP编写Web服务器">使用TCP编写Web服务器</h2>
<p>实现功能：<br>
请求的HTML文件在当前目录存在则返回对应文件，否则返回 404 Not Found</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;running on http://localhost:12000&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connectionSocket, addr = serverSocket.accept()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        message = connectionSocket.recv(<span class="number">2048</span>).decode()</span><br><span class="line">        filename = message.split()[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span>(filename == <span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">            filename = <span class="string">&#x27;/index.html&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename[<span class="number">1</span>:], <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            outputData = f.readlines()</span><br><span class="line">        connectionSocket.send(<span class="string">&#x27;HTTP/1.1 200 OK\r\n\r\n&#x27;</span>.encode())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(outputData)):</span><br><span class="line">            connectionSocket.send(outputData[i].encode())</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        connectionSocket.send(<span class="string">&#x27;HTTP/1.1 404 Not Found\r\n\r\n&#x27;</span>.encode())</span><br><span class="line">        connectionSocket.send(<span class="string">&#x27;Not Found The File&#x27;</span>.encode())</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        connectionSocket.close()</span><br></pre></td></tr></table></figure>
<h2 id="使用UDP编写Ping">使用UDP编写Ping</h2>
<ul>
<li>UDPPingerServer（服务器端程序）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建UDP</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 绑定IP以及端口号</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">12000</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 利用随机数模拟丢包情况</span></span><br><span class="line">    rand = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 接收客户端数据</span></span><br><span class="line">    message, addr = serverSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 生成的随机数小于4则不响应</span></span><br><span class="line">    <span class="keyword">if</span> rand &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 模拟传输时间</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">10</span>)*<span class="number">0.01</span>)</span><br><span class="line">    <span class="comment"># 正常响应客户端</span></span><br><span class="line">    serverSocket.sendto(<span class="string">&quot;来自127.0.0.1的回复&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>), addr)</span><br></pre></td></tr></table></figure>
<ul>
<li>UDPPingerClient （客户端程序）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time, math</span><br><span class="line"></span><br><span class="line"><span class="comment"># UDP</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 服务器IP地址以及端口号</span></span><br><span class="line">serverAddr = (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">12000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在Ping 127.0.0.1 &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计从服务器接收到的包数量</span></span><br><span class="line">receivedPackages = <span class="number">0</span></span><br><span class="line"><span class="comment"># 统计 RTT 往返时间</span></span><br><span class="line">pingTimeList = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 计时, 1s = 1000ms</span></span><br><span class="line">        startTime = time.time()*<span class="number">1000</span></span><br><span class="line">        <span class="comment"># 向服务器发送Ping测试</span></span><br><span class="line">        clientSocket.sendto(<span class="string">&quot;ping&quot;</span>.encode(), serverAddr)</span><br><span class="line">        <span class="comment"># 设置超时为1s</span></span><br><span class="line">        clientSocket.settimeout(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 接收服务器端响应，1s未收到回应则timeout异常</span></span><br><span class="line">        respMessage = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">        endTime = time.time()*<span class="number">1000</span></span><br><span class="line">        <span class="comment"># 接收到的包数量+1</span></span><br><span class="line">        receivedPackages += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 统计往返时间</span></span><br><span class="line">        pingTimeList.append(endTime - startTime)</span><br><span class="line">        <span class="built_in">print</span>(respMessage.decode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">&quot;: 时间=%dms&quot;</span> % pingTimeList[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">except</span> timeout:</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n127.0.0.1的 Ping 统计信息：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据包: 已发送 = 10, 已接收 = %d, 丢失 = %d\n&quot;</span> % (receivedPackages, <span class="number">10</span> - receivedPackages))    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;往返行程的估计时间(以毫秒为单位):&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最短 = %dms，最长 = %dms，平均 = %dms\n&quot;</span> % (<span class="built_in">min</span>(pingTimeList), <span class="built_in">max</span>(pingTimeList), <span class="built_in">sum</span>(pingTimeList)//<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>测试流程：</p>
<ol>
<li>运行<code>UDPPingerServer.py</code></li>
<li>运行<code>UDPPingerClient.py</code></li>
</ol>
]]></content>
      <categories>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关于tomcat、 nginx、apache的理解</title>
    <url>/posts/others_web_server/</url>
    <content><![CDATA[<h1>关于tomcat 与 nginx、apache的理解</h1>
<blockquote>
<p>转载自  - 知乎用户的回答 - 知乎 <a href="https://www.zhihu.com/question/32212996/answer/87524617">https://www.zhihu.com/question/32212996/answer/87524617</a></p>
</blockquote>
<p>HTTP 服务器本质上也是一种应用程序——它通常运行在服务器之上，绑定服务器的 IP 地址并监听某一个 tcp 端口来接收并处理 HTTP 请求，这样客户端（一般来说是 IE, Firefox，Chrome 这样的浏览器）就能够通过 HTTP 协议来获取服务器上的网页（HTML 格式）、文档（PDF 格式）、音频（MP4 格式）、视频（MOV 格式）等等资源。下图描述的就是这一过程：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://pic3.zhimg.com/904696074e077934e601f175913f42fd_r.jpg?source=1940ef5c" alt="img"></p>
<p>不仅仅是 Apache HTTP Server 和 Nginx，绝大多数编程语言所包含的类库中也都实现了简单的 HTTP 服务器方便开发者使用：</p>
<ul>
<li>HttpServer (Java HTTP Server)</li>
<li>Python SimpleHTTPServer</li>
</ul>
<p>使用这些类库能够非常容易的运行一个 HTTP 服务器，它们都能够通过绑定 IP 地址并监听 tcp 端口来提供 HTTP 服务。</p>
<p>Apache Tomcat 则是 Apache 基金会下的另外一个项目，与 Apache HTTP Server 相比，Tomcat 能够<strong>动态</strong>的生成资源并返回到客户端。Apache HTTP Server 和 Nginx 都能够将某一个文本文件的内容通过 HTTP 协议返回到客户端，但是这个文本文件的内容是固定的——也就是说无论何时、任何人访问它得到的内容都是完全相同的，这样的资源我们称之为<strong>静态</strong>资源。动态资源则与之相反，在不同的时间、不同的客户端访问得到的内容是不同的，例如：</p>
<ul>
<li>包含显示当前时间的页面</li>
<li>显示当前 IP 地址的页面</li>
</ul>
<p>Apache HTTP Server 和 Nginx 本身不支持生成动态页面，但它们可以通过其他模块来支持（例如通过 Shell、PHP、Python 脚本程序来动态生成内容）。<br>
如果想要使用 Java 程序来动态生成资源内容，使用这一类 HTTP 服务器很难做到。Java Servlet 技术以及衍生的 Java Server Pages技术可以让 Java 程序也具有处理 HTTP 请求并且返回内容（由程序动态控制）的能力，Tomcat 正是支持运行 Servlet/JSP 应用程序的容器（Container）:</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/2651b72ce2170336d10ad17fd020ae7a_r.jpg?source=1940ef5c" alt="img"></p>
<p>Tomcat 运行在 JVM 之上，它和 HTTP 服务器一样，绑定 IP 地址并监听 TCP 端口，同时还包含以下指责：</p>
<ul>
<li>管理 Servlet 程序的生命周期</li>
<li>将 URL 映射到指定的 Servlet 进行处理</li>
<li>与 Servlet 程序合作处理 HTTP 请求——根据 HTTP 请求生成 HttpServletResponse 对象并传递给 Servlet 进行处理，将 Servlet 中的 HttpServletResponse 对象生成的内容返回给浏览器</li>
</ul>
<p>虽然 Tomcat 也可以认为是 HTTP 服务器，但通常它仍然会和 Nginx 配合在一起使用：</p>
<ul>
<li>动静态资源分离——运用 Nginx 的反向代理功能分发请求：所有动态资源的请求交给 Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript 文件等）则直接由 Nginx 返回到浏览器，这样能大大减轻 Tomcat 的压力。</li>
<li>负载均衡，当业务压力增大时，可能一个 Tomcat 的实例不足以处理，那么这时可以启动多个 Tomcat 实例进行水平扩展，而 Nginx 的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理。</li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>零碎知识</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python Crawler】学习笔记</title>
    <url>/posts/py_spider/</url>
    <content><![CDATA[<h1>Python 爬虫</h1>
<h2 id="验证码识别">验证码识别</h2>
<h3 id="OCR技术">OCR技术</h3>
<blockquote>
<p>OCR（Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程，即针对印刷体字符，采用光学的方式将纸质文档中的文字转换成为黑白点阵的图像文件，并通过识别软件将图像中的文字转换成文本格式，供文字处理软件进一步编辑加工的技术。</p>
</blockquote>
<p>开发环境</p>
<ol>
<li>Python 3.9</li>
<li>pytesseract、pillow模块</li>
<li>Tesseract-OCR引擎</li>
</ol>
<ul>
<li>安装第三方模块</li>
</ul>
<p>pytesseract是Python第三方模块，其原理主要是调用OCR引擎识别图片，OCR引擎再将识别的结果返回到程序中。</p>
<p>PIL模块是专门用于处理图片的模块。安装方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pytesseract</span><br><span class="line">pip install pillow</span><br></pre></td></tr></table></figure>
<ul>
<li>安装OCR引擎</li>
</ul>
<p><a href="https://github.com/tesseract-ocr/tesseract">Tesseract-OCR</a>是一个免费、开源的OCR引擎，以Windows平台为例，<a href="https://digi.bib.uni-mannheim.de/tesseract/">点击下载exe安装包</a>。</p>
<p>OCR测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&quot;test.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将tesseract安装路径添加到系统变量中</span></span><br><span class="line"><span class="comment"># 或者使用以下注释代码，路径改成自己的OCR引擎安装路径</span></span><br><span class="line"><span class="comment"># pytesseract.pytesseract.tesseract_cmd = r&quot;F:\Python\tesseract-ocr\tesseract.exe&quot;</span></span><br><span class="line"></span><br><span class="line">code = pytesseract.image_to_string(im)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(code)</span><br></pre></td></tr></table></figure>
<p>在实际使用时，验证码图片往往会掺入很多干扰因素。为了提高准确率，可以使用PIL模块对图片进行简单的处理，不同的图片有不同的处理方法，其目的都为提高OCR识别的准确率。除此之外，还可以对OCR引擎进行训练和学习。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&quot;old.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图片转为灰度模式</span></span><br><span class="line">im = im.convert(<span class="string">&quot;L&quot;</span>)   </span><br><span class="line"></span><br><span class="line">im.save(<span class="string">&quot;new.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = pytesseract.image_to_string(im)                                                   </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(code)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python爬虫</tag>
      </tags>
  </entry>
</search>
